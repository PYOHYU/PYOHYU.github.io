---
title:  "1.2 Working in 2D"
excerpt: 

categories:
  - Robot
tags:
  - [Robotics]

toc: true
toc_sticky: true
 
date: 2022-03-02
last_modified_at: 2022-03-02

use_math: true
published: true
---

<br>

***

2D 세상, **plane**에서는 익숙한 Euclidean geometry가 있다. Cartesian coord. frame은 수평축 $x$-축과 수직축 $y$-축으로 이루어진다. 두 축의 교점을 **origin**이라고 한다.

두 축에 평행한 단위 벡터들을 $\hat{\textbf{x}}$, $\hat{\textbf{y}}$로 나타내자. 이 $x$-, $y$-축에 대한 point의 좌표는 $(x,y])$ 또는 벡터

$$
p=x \hat{\textbf{x}} + y \hat{\textbf{y}}  \tag{ $1$ }
$$

로 표현된다.

<br>

<p align="center"><img src="/assets/image/robotics/ch2/2.6" width="" height="" title="" alt=""><br/></p>

$\\{B\\}$의 원점이 $\\{A\\}$에 대해 어디에 위치해 있는지 보자. 벡터 $\textbf{t}=\begin{bmatrix}x&y\end{bmatrix}$만큼 떨어져 있으며, 반시계 방향으로 각도 $\theta$만큼 회전해 있다.

따라서, pose를 표현하는 구체적인 기호는 3-vector $^{A}\xi_{B}\sim \begin{bmatrix}x&y&\theta\end{bmatrix}$이다.<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>

<br>

그치만 아쉽게도 이 표현식은 그리 편리하지는 않다. 예를 들어 composition

$$
\begin{bmatrix}x_{1}&y_{1}&\theta_{1}\end{bmatrix} \oplus \begin{bmatrix}x_{2}&y_{2}&\theta_{2}\end{bmatrix}
$$

은 두 pose의 복잡한 삼각 함수로 이루어져 있다. 둘로 나누어서 고려하자. rotation과 translation.

***
### 1.2.1 Orientation

#### Orthonormal Rotation matrix

새로운 frame $\\{V\\}$를 생각하자. Frame $\\{V\\}$는 $\\{A\\}$와 평행하면서 원점이 $\\{B\\}$와 같은 frame이다. 

<p align="center"><img src="/assets/image/robotics/ch2/2.7" width="" height="" title="" alt=""><br/></p>

<br>

식 $(1)$에 의하면 $\\{V\\}$에 대한 점 $\textbf{P}$는 frame의 축에서 정의된 단위벡터들을 이용해,

$$

\begin{align*}
{}^{V}\textbf{p} &=  {}^{V}x\hat{\textbf{x}}_V + {}^{V}y\hat{\textbf{y}}_V \\

&= \begin{bmatrix} \hat{\textbf{x}}_V & \hat{\textbf{y}}_V \end{bmatrix}
\begin{bmatrix} {}^{V}x \\ {}^{V}y \end{bmatrix} \\
\end{align*} \tag{ $ 2 $ }

$$

이렇게 row vector와 column vector의 곱으로 표현된다.

<br>

coord. frame $\\{B \\}$ 역시 이 수직인 두 단위 벡터들로 표현할 수 있다.

$$
\begin{align*}
\hat{\textbf{x}}_B &= \cos \theta \hat{\textbf{x}}_V + \sin \theta \hat{\textbf{y}}_V \\
\hat{\textbf{y}}_B &= -\sin \theta \hat{\textbf{x}}_V + \cos \theta \hat{\textbf{y}}_V \\
\end{align*}
$$

역시 행렬 표현으로,

$$
\begin{bmatrix}
\hat{\textbf{x}}_B & \hat{\textbf{y}}_B
\end{bmatrix}
=
\begin{bmatrix}
\hat{\textbf{x}}_V & \hat{\textbf{y}}_V
\end{bmatrix}

\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix} \tag{ $3$ }
$$

다시 식 $(1)$를 이용하면 $\\{B \\}$에 대한 point $\textbf{P}$는

$$
\begin{align*}
{}^{B}\textbf{p} &=  {}^{B}x\hat{\textbf{x}}_B + {}^{B}y\hat{\textbf{y}}_B \\

&= \begin{bmatrix} \hat{\textbf{x}}_B & \hat{\textbf{y}}_B \end{bmatrix}
\begin{bmatrix} {}^{B}x \\ {}^{B}y \end{bmatrix} \\
\end{align*}
$$

여기에 식 $(3)$를 적용하면,

$$
\begin{align*}
{}^{B}\textbf{p} =  \begin{bmatrix}
\hat{\textbf{x}}_V & \hat{\textbf{y}}_V
\end{bmatrix}

\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}

\begin{bmatrix}
{}^{B}x \\ {}^{B}y
\end{bmatrix}
\end{align*} \tag{ $ 4 $ }
$$

<br>

식 $(2)$와 $(4)$을 보자. 두 식의 우변은 모두 단위벡터 $\hat{\textbf{x}}_V$, $\hat{\textbf{y}}_V$로 표현되어 있다. 둘은 같은 점 $\textbf{P}$를 나타낸 것이므로 계수를 같게 둘 수 있다.
즉,

$$
\begin{bmatrix}
{}^{V}x \\
{}^{V}y
\end{bmatrix}
=
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}

\begin{bmatrix}
{}^{B}x \\ {}^{B}y
\end{bmatrix}
$$

이것이 $\\{B \\}$에서 $\\{V \\}$로 frame이 회전할 때 point를 변환하는 방법을 말해 준다. 이 행렬을 <span style="color:red">rotation matrix</span>라고 하며 $^V\textbf{R}_B$로 쓴다.

$$
\begin{bmatrix}
{}^{V}x \\
{}^{V}y
\end{bmatrix}
=
{}^V\textbf{R}_B

\begin{bmatrix}
{}^{B}x \\ {}^{B}y
\end{bmatrix}
\tag{ $ 5 $ }
$$

<br>

***
#### Orthonormal Rotation matrix의 성질

$$
^X\textbf{R}_Y(\theta) =
\begin{bmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta \\
\end{bmatrix}
$$

는 2D rotational matrix로 다음 성질들을 갖는다.

1. <span style="color:red">Orthonormal</span>. 즉, 각 column들은 unit vector이며 orthogonal이다.

2. 각 column들은 frame $X$에 대하여 회전된 frame $Y$의 축을 정의한다.

3. 이 matrix는 <span style="color:red">special orthogonal group</span>에 속한다. 즉 $\textbf{R} \in SO(2) \subset \mathbb{R}^{2 \times 2}$

4. Determinant는 $+1$이다. 따라서 변환 이후에도 벡터의 길이는 변하지 않는다. 즉, $\Vert {}^Y \textbf{p} \Vert = \Vert {}^X \textbf{p} \Vert, \forall \theta$

5. Inverse는 transpose와 같다. 즉, $\textbf{R}^{-1} = \textbf{R}^T$

<br>

이에 따라 $(5)$를 달리 쓰면,

$$
\begin{bmatrix}
{}^{B}x \\
{}^{B}y
\end{bmatrix}
=
({}^V\textbf{R}_B)^{-1}

\begin{bmatrix}
{}^{V}x \\ {}^{V}y
\end{bmatrix}
=
({}^V\textbf{R}_B)^{T}

\begin{bmatrix}
{}^{V}x \\ {}^{V}y
\end{bmatrix}
=
{}^B\textbf{R}_V

\begin{bmatrix}
{}^{V}x \\ {}^{V}y
\end{bmatrix}
$$

Matrix의 transpose는 위첨자와 아래첨자를 바꾸는 것과 같다. $\textbf{R}(-\theta) = \textbf{R}(\theta)^T$이기 때문.

<br>

***
#### Robotics Toolbox - Rotational Matrix

MATLAB에 Robotics Toolbox에는 로봇 시뮬레이션을 위한 다양한 함수들이 들어 있다. 이걸로 rotation matrix를 간단하게 생성해보자.

<br>

```
R = rot2(0.2)
```

> 결과 :
> 
> &emsp;R = 
> 
> &emsp;&emsp;&emsp;0.9801&emsp;-0.1987
>
> &emsp;&emsp;&emsp;0.1987&emsp;0.9801

각도 $\textrm{0.2 rad}$에서의 rotation matrix를 출력한다.
성질을 확인하자.

```
det(R)
```

> 결과 :
> 
> &emsp;ans = 
> 
> &emsp;&emsp;&emsp;1

<br>

Rotation matrix는 special orthogonal group의 원소이므로, 곱도 rotation matrix.

```
det(R*R)
```

> 결과 :
> 
> &emsp;ans = 
> 
> &emsp;&emsp;&emsp;1

<br>

Robotics Toolbox는 symbolic mathematics도 지원한다.

```
syms theta
R = rot2(theta)
```

> &emsp;R = 
> 
> &emsp;&emsp;&emsp;[cos(theta), -sin(theta)]
>
>&emsp;&emsp;&emsp;[sin(theta),  cos(theta)]

```
simplify(R*R)
``` 

> &emsp;ans =
>
> &emsp;&emsp;&emsp;[cos(2*theta), -sin(2*theta)]
>
> &emsp;&emsp;&emsp;[sin(2*theta),  cos(2*theta)]

``` 
simplify(det(R))
```

> &emsp;ans =
>
> &emsp;&emsp;&emsp;1

<br>

***
#### Matrix Exponential

$\textrm{0.3 rad}$의 pure rotation matrix는

```
R = rot2(0.3)
```

> &emsp;R = 
> 
> &emsp;&emsp;&emsp;0.9553&emsp;-0.2955
>
> &emsp;&emsp;&emsp;0.2955&emsp;0.9553

<br>

MATLAB 내장 함수 `logm`을 이용하면 이 matrix의 logarithm을 계산할 수 있다.

```
S = logm(R)
```

> &emsp;S = 
> 
> &emsp;&emsp;&emsp;0.0000&emsp;-0.3000
>
> &emsp;&emsp;&emsp;0.3000&emsp;0.0000

크기가 0.3인 두 원소가 있는 간단한 행렬이 나왔다. 여기에는 아주 깊은 의미가 숨겨져 있다.<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>

<br>

아무튼, 2D <span style="color:red">skew-symmetric matrix</span>는

$$
\begin{bmatrix}
\omega
\end{bmatrix} _{\times}
=
\begin{bmatrix}
0 & -\omega \\
\omega & 0
\end{bmatrix}
$$

형태이다. 유일한 원소 $\omega in \mathbb{R}$만이 들어있다.

<br>

Skew-symmetric matrix는 대각선 성분이 $0$이다. Robotics Toolbox에는 inverse 연산이 가능한 `vex` 함수가 들어 있다. 유일한 원소를 뽑아내기 위해 `vex`를 취하면

```
vex(S)
```

> &emsp;ans = 
> 
> &emsp;&emsp;&emsp;0.3000

이렇게 회전 각도 값으로 복원됐다.

<br>

Logarithm의 역연산은 exponentiation으로, 역시 MATLAB 내장 함수 `expm`을 이용할 수 있다.

```
expm(S)
```

> &emsp;ans = 
> 
> &emsp;&emsp;&emsp;0.9553&emsp;-0.2955
>
> &emsp;&emsp;&emsp;0.2955&emsp;0.9553

결과는 예상대로 원래의 rotation matrix.

<br>

Toolbox에서 skew-symmetric matrix를 만들고 싶으면,

```
skew(0.3)
```

> &emsp;S = 
> 
> &emsp;&emsp;&emsp;0.0000&emsp;-0.3000
>
> &emsp;&emsp;&emsp;0.3000&emsp;0.0000

<br>

이상의 내용으로 보아, 명령

```
R = rot2(0.3)
```
은
```
R = expm( skew(0.3) )
```
과 같음을 알 수 있다.

<br>

따라서,

$$
\textbf{R} = e^{[\theta]_{\times}} \in SO(2)
$$

로 쓸 수 있다. 여기서 $\theta$는 rotation angle이며, 함수 $[\cdot]_{\times} : \mathbb{R} \mapsto \mathbb{R}^{2 \times 2}$는 scalar값을 skew-symmetric matrix로 만들어 주는 mapping.



<div class="footnotes"><ol>
<li class="footnote" id="fn:1">
<p>
여기서 기호 $\sim$는 두 표현이 동치라는 의미.
<a href="#fnref:1" title=""> ↩</a><p>
<li class="footnote" id="fn:2">
<p>
**Lie group theory**라고...
<a href="#fnref:2" title=""> ↩</a><p>